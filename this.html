<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
    <script>
        /*                    <============== THIS - KEYWORD ===============>
Refernce-Link[
Line-No:
 
22-164   ===> "https://codeburst.io/all-about-this-and-new-keywords-in-javascript-38039f71780c"
         ===> "https://medium.com/free-code-camp/a-guide-to-this-in-javascript-e3b9daef4df1"
           
            ]  


            =>>"this" : keyword refers to an object,
            that object which is executing the current bit of javascript code.

->In other words, every javascript function while executing has a reference to its current execution context,
  called this. Execution context means here is how the function is called.

  Example:1 <========================================================================================>
          
                function bike()
                 {
                   console.log(this.name);
                  }
                 var name = "Ninja";
                 var obj1 = { name: "Pulsar", bike: bike };
                 var obj2 = { name: "Gixxer", bike: bike };

                 bike();           // "Ninja"
                 obj1.bike();      // "Pulsar"
                 obj2.bike();     //Gixxer

         "In These part 'this' act as 
                          =>> Window-Object <<== 
         If you use 'window' instead of these we can directly access name"
<======================================================================================================>

        (1)=>> Default and Implicit binding of “this”

  1==>> If we are in strict mode then the default value of this keyword is undefined otherwise this keyword act as global object,
      it’s called default binding of this keyword. (default is window object in case of browser).

  2==>>when there is an object property which we are calling as a method then that object
       becomes this object or execution context object for that method,
        it is implicit binding of this keyword.
Example:2
            var obj1 = {
              name: "Pulsar",
              bike: function() {
                console.log(this.name);
              }
            }
            var obj2 = { name: "Gixxer", bike: obj1.bike };
            var name = "Ninja";
            var bike = obj1.bike;

            bike();           // "Ninja"
            obj1.bike();      // "Pulsar"
            obj2.bike();      // "Gixxer"

        In the above code snippet, function call bike() is an example of default binding.
        obj1.bike() and obj2.bike() are examples of implicit binding. 
        Here bike function is declared as part of obj1 but regardless of that when we executeobj2.bike(),
        the context of execution is obj2 so obj2.name gets printed.

        It’s important to know how, when and from where the function is called,
        does not matter where function is declared.
<======================================================================================================>

        (2)==>Explicit and Fixed Binding of “this” keyword

               If we use call and apply method with calling function,
               both of those methods take as their first parameter as execution context.
                that is this binding.
 Example:3       <=============================================>

          function bike() {
          console.log(this.name);
             }

      var name = "Ninja";
      var obj = { name: "Pulsar" }

      bike();           // "Ninja"
      bike.call(obj);   // "Pulsar"

In this above snippet, if we call the function bike with call() method passing execution context object obj as first argument,
then obj gets assigned to this object and it prints “Pulsar” which is nothing but obj.name.
It’s called explicit binding of this keyword.

In Fixed binding or Hard binding, we can force the this object to be same always no matter
from where and how it gets called.
Example:4 <=======================================>

   var bike = function() {

       console.log(this.name);

         }
        var name = "Ninja";
        var obj1 = { name: "Pulsar" };
        var obj2 = { name: "Gixxer" };

        var originalBikeFun = bike;
        bike = function() {
          originalBikeFun.call(obj1);
        };

        bike();           // "Pulsar"
        bike.call(obj2);  // "Pulsar"

        As per above code snippet, bike() and bike.call(obj2) both call prints "Pulsar"
        which is nothing butobj1.name means the execution context of the function
        bike is always obj1 and its because of originalBikeFun.call(obj1); 
        These kind of this binding is just another flavor of explicit binding called fixed binding.
<=======================================================================================================>

       (3)==>The “new” keyword in JavaScript

        The new keyword in front of any function turns the function call into constructor call
        and below things occurred when new keyword put in front of function

        A brand new empty object gets created
        new empty object gets linked to prototype property of that function
        same new empty object gets bound as this keyword for execution context of that function call
        if that function does not return anything then it implicit returns this object.
        function bike() {
          var name = "Ninja";
        this.maker = "Kawasaki";
          console.log(this.name + " " + maker);  // undefined Bajaj
        }

        var name = "Pulsar";
        var maker = "Bajaj";

        obj = new bike();
        console.log(obj.maker);                  // "Kawasaki"
        In the above code snippet, bike function is get called with new keyword in front of it.
         So, it creates a new object then that new object gets linked to prototype chain of function bike,
          after that the created new object bound to this object and function returns this object.
           That’s how the returned this object assigned to obj andconsole.log(obj.maker) prints “Kawasaki” .

        In the above code snippet, this.name inside function bike() 
        does not print “Ninja” or “Pulsar” instead it prints undefined
         because the name variable declared inside the function bike() 
         and this.name are totally 2 different things. Same way this.maker and
        maker are different inside function bike() .
         <=================================================>
        ==>Precedence of “this” keyword bindings
         <=================================================>
        => First it checks whether the function is called with new keyword.
        => Second it checks whether the function is called with call or apply method means explicit binding.
        => Third it checks if the function called via context object (implicit binding).
        => Default global object (undefined in case of strict mode).
        <===============================================================================================>
        a,==>         >> Binding<<
          function show(){
            return this;
          }
          var showThis=show.bind({});
          console.log(showThis()) // it gives empty object
          console.log(show()) //it gives window object

        b, ==>
           var a={
             name:"Aravindh"
           }
           var b={
             name:"Divakar"
           }
           function showName(){
             return this.name;
           }
           // I want to print name in a and b object using showName Function
     <=====================================================================>

 <START> 1 ==>  Call for Passing values
            var obj={
              num:5
            }
            var addFun=function(a){
              return this.num + a;
            };

            console.log(addFun.call(obj,3)); // 8
<============================================================================>
         2 ==> Apply for Passing list of datas like array
             var obj={
              num:4
            }
            var addFun=function(a,b,c){
              return this.num + a+b+c;
            };
            
            var arr=[1,2,3];
            console.log(addFun.apply(obj,arr)); // 10
<================================================================================>
         3 ==> Bind
          var obj={
              num:4
            }
            var addFun=function(a,b,c){
              return this.num + a+b+c;
            };
            
            var arr=[1,2,3];
            var bound=addFun.bind(obj);
            console.log(bound(1,2,3)); 
        */

    </script>
    
</body>
</html>
